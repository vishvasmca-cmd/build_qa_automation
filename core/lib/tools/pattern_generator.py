"""
AI-Powered Pattern Generator
Uses LLM to analyze failures and generate custom site-specific methods.
"""

import json
import asyncio
from typing import Dict, Any, List
from termcolor import colored
from core.lib.llm_utils import SafeLLM


class PatternGenerator:
    """
    Analyzes failure patterns and generates custom Python methods
    for site-specific tool behaviors.
    """
    
    def __init__(self):
        self.llm = SafeLLM("gemini-2.0-flash")
    
    async def generate_custom_method(
        self,
        tool_name: str,
        domain: str,
        failures: List[Dict[str, Any]],
        success_trace: Dict[str, Any] = None
    ) -> str:
        """
        Generate a custom Python method based on failure analysis.
        
        Args:
            tool_name: Name of the tool (e.g., 'perform_search')
            domain: Domain name (e.g., 'www.dyson.in')
            failures: List of failure records
            success_trace: Optional successful execution trace for reference
        
        Returns:
            Python code as string for the custom method
        """
        
        # Build analysis prompt
        prompt = self._build_analysis_prompt(tool_name, domain, failures, success_trace)
        
        print(colored(f"ðŸ¤– Asking LLM to generate custom method for {domain}...", "cyan"))
        
        # Get LLM response
        response = await self.llm.ainvoke([
            ("system", "You are an expert Python developer specializing in Playwright automation. Generate clean, efficient, site-specific methods."),
            ("human", prompt)
        ])
        
        # Extract code from response
        code = self._extract_code(response.content)
        
        return code
    
    def _build_analysis_prompt(
        self,
        tool_name: str,
        domain: str,
        failures: List[Dict[str, Any]],
        success_trace: Dict[str, Any]
    ) -> str:
        """Build the LLM prompt for method generation"""
        
        prompt = f"""
TASK: Generate a custom Python method for the `{tool_name}` tool on domain `{domain}`.

## Failure Analysis
The generic implementation failed {len(failures)} times with these patterns:

"""
        for i, failure in enumerate(failures[-3:], 1):
            prompt += f"""
### Failure {i}:
- Error: {failure['error']}
- Context: {json.dumps(failure.get('context', {}), indent=2)}
- URL: {failure.get('url', 'N/A')}

"""
        
        if success_trace:
            prompt += f"""
## Successful Pattern (Manual Fix)
After manual intervention, this pattern worked:

```json
{json.dumps(success_trace, indent=2)}
```
"""
        
        prompt += """
## Requirements
Generate a Python async method with this signature:

```python
async def _{domain_safe}_{tool_name}(self, page: Page, **kwargs) -> Dict[str, Any]:
    \"\"\"
    Custom implementation for {domain}.
    Implements the learned pattern to avoid failures.
    \"\"\"
    # Your implementation here
    pass
```

## Guidelines
1. Use Playwright's async API correctly
2. Include proper error handling
3. Add logging with `self._log()`
4. Return a dict with `{"status": "success"/"failure", ...}`
5. Reference the successful pattern if provided
6. Make it robust and maintainable

IMPORTANT: Return ONLY the Python code, no explanations.
"""
        
        return prompt
    
    def _extract_code(self, response: str) -> str:
        """Extract Python code from LLM response"""
        # Look for code blocks
        if "```python" in response:
            start = response.find("```python") + 9
            end = response.find("```", start)
            return response[start:end].strip()
        elif "```" in response:
            start = response.find("```") + 3
            end = response.find("```", start)
            return response[start:end].strip()
        else:
            # Assume entire response is code
            return response.strip()
    
    def save_generated_method(
        self,
        domain: str,
        tool_name: str,
        code: str
    ):
        """Save generated method to knowledge base"""
        from pathlib import Path
        
        site_dir = Path(f"knowledge/sites/{domain}")
        site_dir.mkdir(parents=True, exist_ok=True)
        
        method_file = site_dir / f"{tool_name}_custom.py"
        
        with open(method_file, 'w') as f:
            f.write(f"""# Auto-generated custom method for {tool_name} on {domain}
# Generated by PatternGenerator

{code}
""")
        
        print(colored(f"ðŸ’¾ Custom method saved to {method_file}", "green"))
